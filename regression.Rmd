---
title: "Regression"
author: 'peacecop kalmer:'
date: "11/9/2021"
output:
  html_document:
    toc: yes
    toc_float: yes
  bookdown::pdf_document2:
    toc: yes
    latex_engine: lualatex
bibliography: references.bib
---

```{r setup, include=FALSE}
options(tinytex.verbose = TRUE)
knitr::opts_chunk$set(echo = TRUE)
```

## Vaskjuhe

```{r cars}
temperatures = c(8, 16.5, 23.5, 32, 40.4, 54.5)
resistancies = c(0.208, 0.213, 0.222, 0.229, 0.232, 0.243)
temperaturesAndResistancies = data.frame(temperatures = temperatures, resistancies = resistancies)
statsForTemperaturesResistancies = lm(formula = resistancies ~ temperatures, data = temperaturesAndResistancies)
summary(statsForTemperaturesResistancies)
plot(temperaturesAndResistancies$temperatures, temperaturesAndResistancies$resistancies)
abline(statsForTemperaturesResistancies)
```

## xy

```{r xy}
x = c(1:5)
y = c(2.1, 3.5, 5.4, 6.2, 8.1)
sizeOfData = length(x)
sizeOfData
sumOfX = sum(x)
sumOfX
sumOfXY = sum(x*y)
sumOfXY
sumOfY = sum(y)
sumOfY
sumOfSquaredX = sum(x ^ 2)
sumOfSquaredX
slopeManually = (sizeOfData * sumOfXY - sumOfX * sumOfY) / (sizeOfData * sumOfSquaredX - sumOfX ^ 2)
slopeManually
interceptManually = (sumOfSquaredX * sumOfY - sumOfX * sumOfXY) / (sizeOfData * sumOfSquaredX - sumOfX ^ 2)
interceptManually
xy = data.frame(x = x, y = y)
statsForXY = lm(formula = y ~ x, data = xy)
summary(statsForXY)
library("ggpubr")
ggscatter(xy, x = "x", y = "y", add = "reg.line", conf.int = TRUE, cor.coef = TRUE, cor.method = "pearson", xlab = "x", ylab = "y")
shapiro.test(xy$x)
shapiro.test(xy$y)
ggqqplot(xy$x, ylab = "x")
ggqqplot(xy$y, ylab = "y")
resultOfPearsonCorrelationTest = cor.test(xy$y, xy$x, method = "pearson")
resultOfPearsonCorrelationTest
resultOfPearsonCorrelationTest$estimate
```
## Sademed

```{r}
temperatures = c(195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210)
radarRainRate = c(150, 150, 150, 118, 109, 95, 63, 66, 44, 29, 29, 35, 38, 31, 20, 24)
precipitants = data.frame(temperature = temperatures, rainRate = radarRainRate)
#plot(x = precipitants$temperature, y = precipitants$rainRate, type = "o", main = "Vihma intensiivsus", xlab = "Temperatuur (K)", ylab = "Vihma hulk (mm / h)")
ggplot(data = precipitants, mapping = aes(x = temperature, y = rainRate)) +
  xlim(180, 230) +
  geom_point() +
  geom_smooth() +
  labs(title = "Vihma intensiivsus", x = "Temperatuur (K)", y = "Vihma hulk (mm / h)") +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")))
statsForPrecipitation = lm(formula = rainRate ~ temperature, precipitants)
summaryForPrecipitation = summary(statsForPrecipitation)
summaryForPrecipitation
```

Vihma hulga muutumise kiirus (mm / h / K) on `r round(summaryForPrecipitation$coefficients[2, 1], digits = 1)`.

Nulltemperatuuri korral võiks mudeli järgi olla vihma (mm / h) `r round(summaryForPrecipitation$coefficients[1, 1], digits = 1)`.

Temperatuur, mille korral 0 mm / h sademeid: `r round(abs(summaryForPrecipitation$coefficients[1, 1] / summaryForPrecipitation$coefficients[2, 1]), digits = 1)` K.

Pearsoni koefitsient: `r cor.test(precipitants$rainRate, precipitants$temperature, method = "pearson")$estimate`

Milline on mudeli põhjal vihma tugevus pilve temperatuuril 230 ja 180 K?

230 K korral on vihma tugevus `r round(summaryForPrecipitation$coefficients[2, 1] * 230 + summaryForPrecipitation$coefficient[1, 1], digits = 1)` mm / h.

180 K korral on vihma tugevus `r round(summaryForPrecipitation$coefficients[2, 1] * 180 + summaryForPrecipitation$coefficient[1, 1], digits = 1)` mm / h.

## Hõbedalahus

```{r}
concentration = c(0, 5, 10, 15, 20, 25, 30)
absorbance = c(0.02, 0.13, 0.25, 0.39, 0.5, 0.62, 0.76)
solution = data.frame(concentration = concentration, absorbance = absorbance)
model0 = lm(absorbance ~ 0 + concentration, solution)
ggplot(data = solution, mapping = aes(x = concentration, y = absorbance)) +
  labs(title = "Valge valguse neelduvus lahuses", x = "Lahuse kontsentratsioon (ng / ml) +/- .25 (ng / ml)", y = "Neelduvus (suhtelised ühikud) +/- 5 % näidust") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  geom_abline(intercept = 0, slope = coef(model0)[1], color = 3) +
  geom_errorbar(aes(ymin = absorbance * .95, ymax = absorbance * 1.05)) +
  geom_errorbarh(aes(xmin = concentration - .25, xmax = concentration + .25))
statsForSolution = lm(formula = absorbance ~ concentration, solution)
summaryForSolution = summary(statsForSolution)
summaryForSolution
```

tõus: `r round(summaryForSolution$coefficients[2, 1], digits = 3)`

*y*-teljega lõikumise koht: `r round(summaryForSolution$coefficients[1, 1], digits = 3)`

## Fotodiood

Fotodioodi pinge sõltuvus temperatuurist on toodud järgnevas tabelis.

Joonistada graafikule sõltuvuse graafik koos veakastidega. Pinge mõõtemääramatuse leidmiseks tuleb arvestada, et mõõtmisi on sooritatud digitaalse mõõteriistaga, mille täpsus on 5%.

Sellest saab leida piirihälbe ning seejärel mõõtemääramatuse 95 % usaldatavuse korral.

Eeldades, et pinge sõltub temperatuurist lineaarselt, leida lineaarse regressiooni parameetrid koos veahinnanguga.

```{r}
temperature = c(2, 10, 19, 26.5, 40.5, 49, 59.5, 65, 80, 91.5, 101.5)
voltage = c(0.686, 0.662, 0.6375, 0.614, 0.59, 0.5415, 0.5175, 0.494, 0.4698, 0.4697, 0.4462)
dataAboutVoltage = data.frame(temperature = temperature, voltage = voltage)
statsForVoltage = lm(formula = voltage ~ temperature, dataAboutVoltage)
summaryForVoltage = summary(statsForVoltage)
summaryForVoltage
library(distributions3)
numberOfTests = length(voltage)
numberOfTests
studentTDistribution = StudentsT(df = numberOfTests - 1)
halfSuccess = .95 / 2
studentTFactor = quantile(studentTDistribution, halfSuccess)
studentTFactor
studentTFactorForInfinity = quantile(StudentsT(df = Inf), halfSuccess)
uncertainty = sqrt((sd(voltage) / sqrt(numberOfTests) * studentTFactor) ^ 2 + (.05 * mean(voltage) * studentTFactorForInfinity / 3) ^ 2 + (halfSuccess * .0001) ^ 2)
```

tõus: `r round(summaryForVoltage$coefficients[2, 1], digits = 4)`

*y*-teljega lõikumise koht: `r round(summaryForVoltage$coefficients[1, 1], digits = 4)`

```{r}
ggplot(data = dataAboutVoltage, mapping = aes(x = temperature, y = voltage)) +
  labs(title = "Fotodioodi pinge sõltuvus temperatuurist", x = "T (°C)", y = "U (V)") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  geom_errorbarh(aes(xmin = temperature - .5, xmax = temperature + .5)) +
  geom_errorbar((aes(ymin = voltage - uncertainty, ymax = voltage + uncertainty)))
```

## Lõuna-Šotimaa

Järgnevas tabelis on toodud Lõuna-Šotimaal erinevates kohtades mõõdetud aastane sademete hulk ning vastav mõõtemääramatus. Ülesanne - luua andmete põhjal graafik, millele on märgitud ka mõõtemääramatused. Koostada lineaarse regressiooni mudel.

```{r}
place = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
height = c(240, 420, 470, 300, 150, 460, 410, 140, 540, 280, 200, 160, 270, 230)
precipitationsInYear = c(1720, 2050, 1870, 1690, 1250, 2090, 2040, 1460, 1860, 1670, 1490, 900, 1250, 1170)
measurementUncertaintyForPrecipitationsInyear = c(50, 70, 70, 100, 50, 100, 70, 70, 120, 70, 50, 50, 70, 50)
precipitations = data.frame(place = place, height = height, precipitationsInYear = precipitationsInYear, measurementUncertaintyForPrecipitationsInyear = measurementUncertaintyForPrecipitationsInyear)
colnames(precipitations) = c("Koha nr", "Kõrgus merepinnast (m)", "Sademete hulk (mm/aastas)", "Mõõtemääramatus sademete hulga jaoks (mm/aastas)")
library(kableExtra)
precipitations %>% kbl(caption = "Lõuna-Šotimaa sademed") %>% kable_styling(bootstrap_options = c("striped", "hover"))
modelForPrecipitations = lm(precipitationsInYear ~ height, precipitations)
modelForPrecipitations
modelForPrecipitations$coefficients[1]
ggplot(data = precipitations, mapping = aes(x = height, y = precipitationsInYear)) +
  labs(x = "Kõrgus merepinnast (m)", y = "Sademete hulk (mm/aastas)") +
  geom_point() +
  geom_line() +
  geom_abline(intercept = modelForPrecipitations$coefficients[1], slope = modelForPrecipitations$coefficients[2], color = 3) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  geom_errorbar((aes(ymin = precipitationsInYear - measurementUncertaintyForPrecipitationsInyear, ymax = precipitationsInYear + measurementUncertaintyForPrecipitationsInyear)))
summaryForPrecipitations = summary(modelForPrecipitations)
summaryForPrecipitations
```

## Neeldumine

On antud spektroskoopilised neeldumiskõverad - neeldumise sõltuvus albumiini võ glütsiini kontsentratsioonist. Skitseerida mõlema juhu jaoks lineaarse regressiooni graafikud ning ruutsõltuvuse (2. järku polünoomi) graafikud. Juhul, kui lineaarne sõltuvus sobib, leida lineaarse mudeli parameetrite puhul ka intercept'i ja slope'i standardhälbed. Lisaküsimus - kuidas lisada graafikule veakastid ja millised veakastid peaksid siin olema?

```{r}
concentration = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
absorbance = c(0, 80.33, 135.7, 207, 243.3, 303, 329, 370.3, 406, 431.7, 444.3)
albumin = data.frame(concentration = concentration, absorbance = absorbance)
modelForAlbumin = lm(formula = absorbance ~ -1 + I(concentration ^ 2) + concentration, data = albumin)
modelForAlbumin
linearModelForAlbumin = lm(formula = absorbance ~ concentration, data = albumin)
linearModelForAlbumin
summaryForAlbumin = summary(linearModelForAlbumin)
summaryForAlbumin
ggplot(data = albumin, mapping = aes(x = concentration, y = absorbance)) +
  labs(x = "Kontnsentratsioon c", y = "Neelduvus N") +
  geom_point() +
  geom_line() +
  geom_smooth(method = "lm", formula = y ~ -1 + x, fill = "orange") +
  geom_smooth(method = "lm", formula = y ~ -1 + I(x ^ 2) + x, fill = "firebrick") +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = y ~ -1 + x, label.x = 3, label.y = 34) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = y ~ -1 + I(x ^ 2) + x)
```

Suvalist [regressioonigraafikut saab arvutada ka käsitsi](http://polynomialregression.drque.net/math.html). See oleks huvitav kunagi läbi teha.

## Takistused

Pooljuhi takistus on läbi pooljuhi mineva voolu tugevuse funktsioon $R=f(I)$. Eeldame, et see seos on järgmine: ($R=k\cdot I^{n}$). Joonistada graafik, logaritmiline graafik. Leida konstandid *k* ja *n*.

```{r}
i = c(.001, .002, .004, .008, .016, .032, .064, .13, .26, .52)
r = c(.0006, .0022, .0063, .02, .042, .12, .34, 1.1, 3.2, 9.5)
resistancies = data.frame(i = i, r = r)
colnames(resistancies) = c("I(A)", "R(Ω)")
resistancies %>% kbl(caption = "Takistused") %>% kable_styling(bootstrap_options = c("striped", "hover"))
modelForResistancies = lm(log(r) ~ log(i))
summary(modelForResistancies)
ggplot(data = resistancies, mapping = aes(x = i, y = r)) +
  labs(x = "I(A)", y = "R(Ω)") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  scale_x_log10(limits = c(1e-3, 1)) +
  scale_y_log10(limits = c(1e-4, 10)) +
  theme_bw() +
  annotation_logticks() +
  stat_function(fun = function (x) exp(coef(modelForResistancies)[1]) * x ^ coef(modelForResistancies)[2], color = "red")
```

*k*: `r exp(coef(modelForResistancies)[1])`

*n*: `r coef(modelForResistancies)[2]`

## Poollogaritmika

Tabelis on toodud andmed seose $z=a*10^{b*x}$. Leida konstandid *a* ja *b* ning joonistada graafik tavalises ja poollogaritmilises teljestikus.

```{r}
x = c(.1, .2, .4, .6, 1, 1.5, 1.8, 2, 2.2, 2.5, 3.2, 4)
z = c(2.4, 2.75, 3, 3.4, 4.1, 5.7, 6.8, 7.5, 8.8, 10.1, 15, 24)
halfLogarithmics = data.frame(x = x, z = z)
halfLogarithmics %>% kbl(caption = "Poollogaritmika") %>% kable_styling(bootstrap_options = c("striped", "hover"))
modelForHalfLogarithmics = lm(log(z) ~ x)
modelForHalfLogarithmics
summaryForModelForHalfLogarithmics = summary(modelForHalfLogarithmics)
summaryForModelForHalfLogarithmics
ggplot(data = halfLogarithmics, mapping = aes(x = x, y = z)) +
  labs(x = "x", y = "z") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = log(z) ~ x)+
  labs(title = paste()) +
  stat_function(fun = function (x) exp(coef(modelForHalfLogarithmics)[1]) * exp(coef(modelForHalfLogarithmics)[2]) * x, color = "red") +
  annotation_logticks() +
  scale_y_log10(limits = c(1, 100))
```

$$z=`r round(exp(modelForHalfLogarithmics$coefficients[1]), digits = 4)`*10^{`r round(modelForHalfLogarithmics$coefficients[2], digits = 4)`*x}$$

$$R^{2}=`r summaryForModelForHalfLogarithmics$r.squared`$$

## CaCO

Tabelis on toodud süsteemi - CaCO tahkis-vedelik-gaas tasakaalulised kontsentratsioonid ja vedeliku happelisuse tasemed. Teha a) graafik I veerg vs viimane veerg, b) teine veerg vs viimane veerg. Tavalises ja poollogaritmilises teljestikus. Leida võimalusel sobiv fit-funktsioon. Üks võte numbrite sisestamisel. Nt 8.08*10^-7 on tabelis kujul 9.08E-07 ning 2.37*10^4 on kujul 2.37E04

```{r tableForSolidFluidGas}
ppmCo2 = c(0.000000808, 0.0000255, 0.000295, 0.00295, 0.0295, 0.295, 0.692, 2.95, 29.5, 88.5, 295, 390, 885, 2950, 23700)
mmolLCo2 = c(2.74E-11, 8.66E-10, 0.00000001, 0.0000001, 0.000001, 0.00001, 0.0000235, 0.0001, 0.001, 0.003, 0.01, 0.0132, 0.03, 0.1, 0.802)
mmolLCox = c(0.000566, 0.00187, 0.00455, 0.0111, 0.029, 0.0748, 0.103, 0.173, 0.375, 0.541, 0.812, 0.893, 1.19, 1.82, 4.25)
mmolLCa = c(5.05, 1.6, 0.71, 0.33, 0.17, 0.11, 0.1, 0.12, 0.2, 0.28, 0.41, 0.44, 0.58, 0.86, 1.73)
pH = c(12, 11.5, 11.15, 10.81, 10.46, 10.06, 9.88, 9.54, 8.92, 8.61, 8.27, 8.19, 7.95, 7.6, 7)
solidFluidGas = data.frame(ppmCo2 = ppmCo2, mmolLCo2 = mmolLCo2, mmolLCox = mmolLCox, mmolLCa = mmolLCa, pH = pH)
colnames(solidFluidGas) = c("$P(CO_{2})_{G}, ppm$", "$[CO_{2}]_{W}, mmol/L$", "$\\sum[CO_{X}]_{W}, mmol/L$", "$[Ca^{2+}], mmol/L$", "pH")
solidFluidGas %>% kbl(caption = "Equilibrium concentrations of $[CO_{2}]_{W}$, $HC_{3}^{-}$, and $Ca^{2+}$ and pH in the system of gas-water-solid $CaCO_{3}$ at $t = 25 °C$. Boldface designates extremal of $Ca^{2+}$ and $CO_{3}^{2-}$ at $[CO_{2}]_{W}\\cong2.35\\times10^{-5} mmol/L$") %>% kable_styling(bootstrap_options = c("striped", "hover")) %>% row_spec(7, bold=T)
modelForCo2 = lm(pH ~ log(mmolLCo2))
modelForCo2
summaryForModelForCo2 = summary(modelForCo2)
summaryForModelForCo2
ggplot(data = solidFluidGas, mapping = aes(x = mmolLCo2, y = pH)) +
  labs(x = "CO2/mmol/L", y = "pH") +
  geom_point() +
  geom_line() +
  ylim(6, NA) +
  annotation_logticks(sides ="tb") +
  scale_x_log10(limits = c(.00000000001, 1))
```

pH sõltuvus CO_2_'st:

$$z=`r round(modelForCo2$coefficients[2], digits = 4)`*ln(x)+{`r round(modelForCo2$coefficients[1], digits = 4)`}$$

$$R^{2}=`r summaryForModelForCo2$r.squared`$$

```{r}
modelForCox = lm(pH ~ log(mmolLCox))
modelForCox
summaryForModelForCox = summary(modelForCox)
summaryForModelForCox
ggplot(data = solidFluidGas, mapping = aes(x = mmolLCox, y = pH)) +
  labs(x = "COx/mmol/L", y = "pH") +
  geom_point() +
  geom_line() +
  ylim(6, NA) +
  stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  scale_x_log10(limits = c(.0001, 10))

```

pH sõltuvus CO_X_'st:

$$z=`r round(modelForCox$coefficients[2], digits = 4)`*ln(x)+{`r round(modelForCox$coefficients[1], digits = 4)`}$$

$$R^{2}=`r summaryForModelForCox$r.squared`$$

```{r}
ggplot(data = solidFluidGas, mapping = aes(x = mmolLCa, y = pH)) +
  labs(x = "Ca2+/mmol&L", y = "pH") +
  #geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")))
  #stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10(limits = c(.0001, 10))

```

## Eksponentsiaalne sõltuvus

### Ülesande püstitus

Leida järgnevatest kaks andmerida:

- inimkonna arvukuse kasv

- nafta kulutamine (aastas)

- energia kulutamine (aastas)

- CO2 aastane emissioon (aastas)

kogu maailma kohta.

Teha nende kahe valitud andmejada kohta graafikud ning leida eksponentsiaalse sõltuvuse funktsioonid graafiku järgi (Trendline abil).

Teha nende kahe andmejada kohta korrelatsioonanalüüs - näiteks CO-2 y-teljel ja nafta kulutamine x-teljel.

Tuleb arvestada, et nt nafta tootmine või CO2 emissioon hakkas eksponentsiaalselt kasvama alles industriaalajastuga, siis peaks aja jaoks tegema ümber arvutuse. Nt tähistama aasta 1900 0-ks. 1910 oleks siis aasta 10 jne.

### Algandmed

```{r}
year = c(1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020)

population=c(2536431,2584034,2630862,2677609,2724847,2773020,2822443,2873306,2925687,2979576,3034950,3091844,3150421,3211001,3273978,3339584,3407923,3478770,3551599,3625681,3700437,3775760,3851651,3927781,4003794,4079480,4154667,4229506,4304534,4380506,4458003,4536997,4617387,4699569,4784012,4870922,4960568,5052522,5145426,5237441,5327231,5414289,5498920,5581598,5663150,5744213,5824892,5905046,5984794,6064239,6143494,6222627,6301773,6381185,6461159,6541907,6623518,6705947,6789089,6872767,6956824,7041194,7125828,7210582,7295291,7379797,7464022,7547859,7631091,7713468,7794799)

co2Emissions = c(5998250390, 6374254691, 6460339682, 6641273014, 6784215194, 7436238817, 7917168948, 8178702419, 8411438653, 8847900121, 9359426482, 9388244087, 9719779635, 10239773013, 10793877121, 11282700958, 11829640492, 12205845914, 12871319383, 13724862841, 14853217232, 15453605261, 16173079951, 17027165013, 16957206737, 16999328068, 17933956104, 18444838983, 19016691375, 19557553854, 19444411140, 18980238345, 18830746953, 18949762962, 19604480685, 20262211219, 20559974625, 21191788543, 22012236539, 22320123319, 22749574361, 23238102148, 22569624280, 22803495350, 22964583360, 23453944453, 24154961205, 24300550431, 24206271270, 24518962289, 25234207250, 25451054499, 26039191478, 27366723290, 28627533035, 29602777195, 30583530082, 31493741589, 32069444008, 31607042411, 33343300453, 34468451046, 34974075146, 35283025442, 35534442951, 35496406338, 35452459300, 35925737688, 36646139785, 36702502902, 34807259099)

world = data.frame(year = year, population = population, co2Emissions = co2Emissions)
library(htmltools)
colnames(world) = c("Aasta", "Tuhat inimest [@people]", '$CO_{2}$ emissioone (t / y) [@owidenergy]')

world %>% kbl(caption = "Maailma inimeste arv ja süsinikdioksiidi aastane emissioon aastates 1950 - 2020 seisuga 20211120", longtable = T, booktabs = T) %>% kable_styling(bootstrap_options = c("striped", "hover"), latex_options = c("repeat_header"))
```

### Lahendus

```{r}
ggplot(data = world, mapping = aes(x = population, y = co2Emissions)) +
labs(x = "Tuhat inimest", y = bquote(CO[2] ~ 'emissioone (t / y)')) +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = co2Emissions ~ population)
  #stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10(limits = c(.0001, 10))
modelForWorld = lm(co2Emissions ~ population)
summaryForModelForWorld = summary(modelForWorld)
summaryForModelForWorld
```

Inimeste arvu suurenemine maailmas ja süsinikdioksiidi heitmete suurenemine maailmas oli aastail 1950 - 2020 tugevas lineaarses seoses. Kuna seos on lineaarne, siis pole mõtet aretada eksponentsiaalset graafikut.

Uurin eraldi sõltuvust inimeste populatsiooni ja aja vahel:

```{r}
ggplot(data = world, mapping = aes(x = year, y = population)) +
labs(x = "Aasta", y = "Tuhat inimest") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = population ~ year)
  #stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10(limits = c(.0001, 10))
modelForPopulation = lm(population ~ year)
summaryForModelForPopulation = summary(modelForPopulation)
summaryForModelForPopulation

```

Inimeste arvu suurenemine on otseses sõltuvuses ajakulgust. Kuna inimeste arvu kasv on otseses sõltuvuses aja kulgust ja inimeste arvuga korreleerub tugevasti süsinikdioksiidi heitmete mass, siis on järelikult ka vähemalt tugev lineaarne sõltuvus aja kulgu ja süsinikdioksiidi heitmete massi vahel. Nii et valitud andmeridade vahel ei ole eksponentsiaalset seost.

Kui surfata lehel, kust pärinevad süsinikdioksiidi heitmete arvud [@owidenergy], leiame sealt graafiku energiatarbimise kohta, mis ei erine käsitletavas ajavahemikus teistest käsitletud graafikutest - korrelatsioon on tugevalt lineaarne ajaga. Sama paistab ka fossiilsete kütuste tarbimise kohta.

Võiks muidugi võtta pikema ajavahemiku ja nautida näiliselt eksponentsiaalset seost. Ometi oleks see petlik, sest kuigi graafikute tõus on enne 1950. aastat oluliselt väiksem, tähendab see siiski vaid n-ö käivitusaega ja kui juba käivitamine on toimunud, on kulgemine toimunud lineaarselt. See üllatab mind, sest arvasin ka varem, et rahvaarv kasvab eksponentsiaalselt. Selgus, et see polegi nii.

### Arutelu õpetajaga

Ajaperiood ongi liiga lühike. Eksponentsiaalne kasv eeldab piiramatuid resursse. Või piiramatult kasutusele võetavaid resursse. Lühikest ajaperioodi saab alati lineaarse kasvuga sobitada. Ja eksponentfunktsiooni graafikut saab alati mingis ajaperioodis lineaarsega lähendada.
Ning seaduste, reeglitega nt rahvaarvu kasvu piirata. Või sõdadega. Või suurendada, nt antibiootikumide kasutuselevõtt tõstis inimeste arvukuse kasvamise kiirust oluliselt.
Aga võttes aluseks nt inimkonna arvukuse modelleerimisel või matemaaeksponentsialse kasvu vs lineaarne, sõltub sellest, millest on inimeste arvu kasv tingitud.
Eksponentsiaalne kasv on juhul kui varusid on piiramatult ning aastas juurdetulevate inimeste arv sõltub olemasolevate arvust. Nt iga miljoni inimese kohta 1000 inimest juurde, seega 10 miljoni kohta 10000 inimest juurde, 1 miljardi kohta aastas juurdekasv 1 miljon. Jne.
Lineaarne kasv arvestab, et juurdesündivate inimeste arv ei sõltu olemasolevate arvust. See võiks juhtuda kui varusid on piiratud või pannakse mingiks ajaperioodiks paika reeglid, mille rakendamisel surutakse inimeste arvu kasv maha. Kui nt Eestis iive on null, siis sobib lineaarse kasvu mudel väga hästi. Eksponentsiaalse oma sobiks siis kah.

Demograafia tegeleb eraldi nende faktoritega erinevates rikides, maailmajagudes ja maailmas tervikuna.

Parimat,
Tõnu Laas

On Sat, Nov 20, 2021 at 10:56 PM peacecop kalmer: <kalmer@test.tennis24.ee> wrote:
Tegin analüüsi ära. Kõige enam aega kulus algandmete otsimisele ja mõningate tehniliste lahenduste otsimisele, mis puudutab "Bookdown"'i "RStudio"'s. Palun vaata mu lahendust aadressilt http://statistika.tennis24.ee/regression.html#Eksponentsiaalne_s%C3%B5ltuvus Ülesande lahendus on lehe lõpuosas. Vasakult menüüst saad valida "Eksponentsiaalse sõltuvuse". Võiksid pilgu ka "Poollogaritmikale" ja "CaCO"'le peale visata, et kas need tulemis on sellised, nagu sa ootasid.

Mul pole mõtet mitte ühtki faili üles laadida, kuna kõik on seal lehel näha ja ma ei püüdnudki tabelarvutusprogrammis sellega seekord tegeleda.

Ei tule kuidagi realistlikku eksponentsiaalset seost nende andmetega, kui me just end ei peta. Eksponentsiaalne seos tähendaks, et ka nt ajavahemikus 2000 - 2020 iga aasta kohta suurenes miski järjest rohkem. Aga tuli välja, et suurenes alati ühepalju. Muidugi võiks arendada mingi multigraafiku, mille algus on eksponentsiaalne, praegune osa lineaarne, ometi kui midagi ennustada, siis pigem lineaarse jupi alusel, mis on juba 70 aastat püsinud.

### Täiendatud algandmed

Kuna maailma rahvaarvu kohta pole nii täpseid andmeid 1950. aastast varasema aja kohta kui alates 1950. aastast, käsitlen täiendatud algandmeid alates aastast 1750 intervalliga 50 aastat:

```{r}
year1 = c(1750, 1800, 1850, 1900, 1950, 2000)

population1=c(814000, 990000, 1263000, 1654000, 2536431, 6143494)

co2Emissions1 = c(9350528, 28091888, 196896032, 1952224654, 6003238189, 25234207250)

world1 = data.frame(year = year1, population = population1, co2Emissions = co2Emissions1)
colnames(world1) = c("Aasta", "Tuhat inimest [@people] [@population]", '$CO_{2}$ emissioone (t / y) [@owidenergy] [@co2]')

world1 %>% kbl(caption = "Maailma inimeste arv ja süsinikdioksiidi aastane emissioon aastates 1750 - 2020 seisuga 20211121") %>% kable_styling(bootstrap_options = c("striped", "hover"))
```

### Lahendus täiendatud algandmetega

```{r}
ggplot(data = world1, mapping = aes(x = population1, y = co2Emissions1)) +
  labs(x = "Tuhat inimest", y = bquote(CO[2] ~ 'emissioone (t / y)')) +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth()
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = co2Emissions1 ~ population1) 
  #stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10() 
  #scale_y_log10()
modelForWorld1 = lm(co2Emissions1 ~ population1)
summaryForModelForWorld1 = summary(modelForWorld1)
summaryForModelForWorld1
```

Nagu graafikult näha, ei olnud perioodi pikendamine abiks ja graafik kinnitab mu eelnevat juttu, et jalgrattaga sõitma hakates toimub kiirendamine aeglasemalt, misjärel kiiremini, misjärel on kiirus ühtlane. Kui muuta see graafik logaritmiliseks, ei teki lineariseeritust.

Uurin eraldi sõltuvust inimeste populatsiooni ja aja vahel:

```{r}
modelForPopulation1 = lm(log(population1) ~ year1)
ggplot(data = world1, mapping = aes(x = year1, y = population1)) +
  labs(x = "Aasta", y = "log(Tuhat inimest)") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = log(population1) ~ year1) +
  stat_function(fun = function (x) exp(coef(modelForPopulation1)[1]) * exp(coef(modelForPopulation1)[2] * x), color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10() 
  scale_y_log10()
summaryForModelForPopulation1 = summary(modelForPopulation1)
summaryForModelForPopulation1
```

R ruudus on .91, kui lineariseerida graafik selliselt, et ordinaattelg logaritmida. Seega on seos aja kulgu ja inimeste hulga suurenemise vahel maailmas niimoodi tugev.

Uurin eraldi sõltuvust süsinikdioksiidi emissioonide ja aja vahel:

```{r}
modelForCo2Emissions1 = lm(log(co2Emissions1) ~ year1)
ggplot(data = world1, mapping = aes(x = year1, y = co2Emissions1)) +
  labs(x = "Aasta", y = "Süsinikdioksiidi emissioone (log(t))") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = log(population1) ~ year1) +
  stat_function(fun = function (x) exp(coef(modelForCo2Emissions1)[1]) * exp(coef(modelForCo2Emissions1)[2] * x), color = "red") +
  annotation_logticks(sides ="lr") +
  #scale_x_log10() 
  scale_y_log10()
summaryForModelForCo2Emissions1 = summary(modelForCo2Emissions1)
summaryForModelForCo2Emissions1
```

R ruudus on .9891, kui lineariseerida graafik selliselt, et ordinaattelg logaritmida. Seega on seos aja kulgu ja süsinikdioksiidi emissioonide suurenemise vahel maailmas niimoodi tugev.

Nii et ühe ajaühiku kohta ajavahemikus 1950 - 2020 suurenesid nii inimeste arv maailmas kui süsinikdioksiidi heitmete mass eksponentsiaalselt, kuigi omavahel on nendel lineaarne sõltuvus.

## Pendel

Alljärgnevas tabelis on toodud matemaatilise pendli (niidi otsa riputtatud kuulike) võnkeperioodi T sõltuvus pendli pikkusest l.

Arvestades, et matemaatilise pendli võnkeperiood sõltub pendli pikkusest järgmiselt:

$$T=2\pi*\sqrt{\frac{l}{g}}$$

Selleks

a) joonistage graafik, tähistades ka veakastid arvestades, et pikkuse mõõtmise Jaoks on viga 0,01m ning aja jaoks 0,01s. Lisage joonisele ka telgede tähistused,

b) tehke tabelisse uus veerg, x = sqrt{l}. Sel juhul

$$T=\frac{2*\pi}{\sqrt{g}}*x\equiv k*x$$

c) Skitseerige graafik ka uue sõltuvuse, T = k * x jaoks, leidke sellest tõus 'slope' ning selel abil g.

d) Teine võimalus, võttes mõlemad pooled ruutu saame seose:  $T^{2}=\frac{4*\pi^{2}}{g}*l$ Võttes y=T^2^ saame ka sin lineaarse seose. Ülesanne: Leida antud juhul seosest y = k * l abil esmalt ka ja siis g.

```{r}
l = c(.2, .25, .28, .32, .37, .4, .52)
t = c(.9, 1.01, 1.06, 1.13, 1.23, 1.27, 1.46)
pendulum = data.frame(l = l, t = t)
colnames(pendulum) = c("l (m)", "T (s)")
library(kableExtra)
pendulum %>% kbl(caption = "Matemaatilise pendli võnkeperioodi <i>T</i> sõltuvus pendli pikkusest <i>l</i>") %>% kable_styling(bootstrap_options = c("striped", "hover"))

ggplot(data = pendulum, mapping = aes(x = l, y = t)) +
  labs(x = "l(m)", y = "T(s)") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  annotation_logticks(sides ="lr")

xForPendulum = sapply(l, function(l) round(sqrt(l), digits = 3))
pendulum$xForPendulum = xForPendulum
colnames(pendulum) = c("l (m)", "T (s)", "x=sqrt(l)")

pendulum %>% kbl(caption = "Matemaatilise pendli võnkeperioodi <i>T</i> sõltuvus pendli pikkusest <i>l</i> lisamuutujaga") %>% kable_styling(bootstrap_options = c("striped", "hover"))

modelForPendulum = lm(t ~ xForPendulum)

formula = y ~ xForPendulum

k = coef(modelForPendulum)[2]

librarian::shelf(ggpmisc)
library(ggpubr)
ggplot(data = pendulum, mapping = aes(x = xForPendulum, y = t)) +
  labs(x = "x=sqrt(l)", y = "T(s)") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = formula) +
  stat_poly_eq(eq.with.lhs = "t~`=`~", eq.x.rhs = "~x", aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), parse = TRUE, formula = formula) +
  stat_function(fun = function (xForPendulum) k * xForPendulum + coef(modelForPendulum)[1], color = "red") +
  annotation_logticks(sides ="lr")

```

*k* = `r k`

*g* = `r round(4 * pi ^ 2 / k ^ 2, digits = 3)`

Pärast seda, kui sundida trendijoon läbi junni, on konstantide väärtused sellised:

```{r}

modelForPendulumWithForced0 = lm(t ~ xForPendulum - 1)

formulaWithForced0 = y ~ xForPendulum - 1

kWithForced0 = coef(modelForPendulumWithForced0)[1]
library(ggpubr)
ggplot(data = pendulum, mapping = aes(x = xForPendulum, y = t)) +
  labs(x = "x=sqrt(l)", y = "T(s)") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = formulaWithForced0) +
  stat_poly_eq(eq.with.lhs = "t~`=`~", eq.x.rhs = "~x", aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), parse = TRUE, formula = formulaWithForced0) +
  stat_function(fun = function (xForPendulum) kWithForced0 * xForPendulum, color = "red") +
  annotation_logticks(sides ="lr")
  #scale_x_log10() 
  #scale_y_log10()

kWithForced0
modelForPendulumWithForced0
summaryForModelForPendulumWithForced0 = summary(modelForPendulumWithForced0)
summaryForModelForPendulumWithForced0
standardDeviationForK = coef(summaryForModelForPendulumWithForced0)[, 2]
f=expression(4 * pi^2 / kForDerivative ^ 2)
derivative = D(f, "kForDerivative")
derivative
kForDerivative = kWithForced0
abs(eval(derivative)) * standardDeviationForK
gWithForced0 = round(4 * pi ^ 2 / kWithForced0 ^ 2, digits = 3)
standardDeviationForG = abs(eval(derivative)) * standardDeviationForK

library(distributions3)
numberOfMeasurements = nrow(pendulum)
numberOfMeasurements
studentTDistribution = StudentsT(df = numberOfMeasurements - 1)
studentTDistribution
studentTFactor = quantile(studentTDistribution, 1 - .05 / 2)
studentTFactor

```

*k* = `r kWithForced0`

*g* = `r gWithForced0`

*k* standardhälve: `r standardDeviationForK`

*g* standardhälve: `r standardDeviationForG`

minimaalne *g*: `r gWithForced0 - standardDeviationForG`

maksimaalne *g*: `r gWithForced0 + standardDeviationForG`

*Δ g*: `r standardDeviationForG / sqrt(numberOfMeasurements) * studentTFactor`

## Kuulmislävi

Inimese kuulmislävi on umbes 30 dB, mis vastab helirõhu muutusele .00063 Pa võrra. Millisel kaugusel heliallikast see praktiliselt kuuldamatu, kui on teada, et heli nõrgeneb kauguse suurenedes vastavalt seosele p=A/r^2^ +b, kui on teada, et allika läheduses on helirõhu mõõtmised eri kaugustel järgmised:

```{r}
r = c(2, 10, 15, 25)
p = c(1.15, .6, .52, .4)
sound = data.frame(r = r, p = p)
colnames(sound) = c("r (m)", "p (Pa)")
library(kableExtra)
sound %>% kbl(caption = "Helirõhud ja kaugused") %>% kable_styling(bootstrap_options = c("striped", "hover"))
```

Selleks lineariseerige algne võrrand võttes uueks muutujaks x=1/r^2^. Seejärel leidke uue muutuja x ja p vaheline lineaarne võrrand y=A x + b. Ning siis leidke algse võrrandi abil kaugus r.

```{r}
xForSound = sapply(r, function(r) 1 / r ^ 2)
if(!("x=1/r^2" %in% colnames(sound))) {
  sound$xForSound = xForSound
}
print(sound)
colnames(sound) = c("r (m)", "p (Pa)", "x=1/r^2")

sound %>% kbl(caption = "Helirõhud ja kaugused lisamuutujaga") %>% kable_styling(bootstrap_options = c("striped", "hover"))
library(ggplot2)
library(ggpmisc)
formulaForSound = y ~ -1 + x
ggplot(data = sound, mapping = aes(x = xForSound, y = p)) +
  labs(x = "x=1/r^2", y = "p (Pa)") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth(method = "lm", formula = formulaForSound, fill = "orange") +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  stat_poly_eq(eq.with.lhs = "p~`=`~", eq.x.rhs = "~1/r^2", aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = formulaForSound, parse = TRUE) 
  #stat_function(fun = function (xForPendulum) kWithForced0 * xForPendulum, color = "red") +
  #annotation_logticks(sides ="lr")
  #scale_x_log10() 
  #scale_y_log10()
ggplot(data = sound, mapping = aes(x = r, y = p)) +
  labs(x = "r", y = "p") +
  geom_point() +
  geom_line()
```

## Aktiivsus

Radioaktiivse elemendi Po210 aktiivsus langes aja jooksul järgmiselt:

```{r}
timeForActivity = c(0, 4, 8, 11, 15, 18, 21, 25, 29, 32)
a = c(19520, 18620, 19180, 16920, 18620, 16500, 17527, 16562, 17210, 16030)
activity = data.frame(timeForActivity = timeForActivity, a = a)
colnames(activity) = c("Aeg t (päev)", "Aktiivsus A")
library(kableExtra)
activity %>% kbl(caption = "Aktiivsus") %>% kable_styling(bootstrap_options = c("striped", "hover"))

```

Radioaktiivse elemendi aktiivsus kahaneb aja jooksul vastavalt radioaktiivse lagunemise seadusele: $A=A_0 e^{-\lambda t}$, kus $A_0$ on konstant (aktiivsus ajahetkel 0) ja $\lambda$ on radioaktiivse lagunemise konstant. Elemendi poolestusaeg $\tau =\frac{ln2}{\lambda}=\frac{0,692}{\lambda}$. Leida tabelis toodud andmete põhjal polooniumi isotoobi radioaktiivse lagunemise konstant ja poolestusaeg.

```{r}
formulaForActivityExp = log(a) ~ timeForActivity
modelForActivity = lm(formula = formulaForActivityExp)
modelForActivity
summaryForModelForActivity = summary(modelForActivity)
summaryForModelForActivity
library(ggplot2)
library(ggpmisc)
ggplot(data = activity, mapping = aes(x = timeForActivity, y = log(a))) +
  labs(x = "t (päev)", y = "log(A) (lagunemist/min)") +
  geom_point() +
  geom_line() +
  geom_abline(intercept = modelForActivity$coefficients[1], slope = modelForActivity$coefficients[2]) +
  #geom_smooth(method = "lm", formula = log(a) ~ log(), fill = "orange")+
  stat_poly_eq(eq.with.lhs = "A~`=`~", eq.x.rhs = "~t", aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), parse = TRUE) 
  #stat_smooth(method = "nls", method.args = list(start = c(a = 1, b = 1)), formula = y ~ a * exp(b * x))
lambda = -(modelForActivity$coefficients[2])
```

lambda: `r lambda`

tau: `r log(2) / lambda`

```{r}
library(dplyr)
activity = activity %>%
  mutate("y=ln A" = log(a))
activity
```

$$\sigma(\tau) = |\frac{d(\tau)}{d(\lambda)}| \cdot \sigma(\lambda) === |\frac{d(\frac{ln(2)}{\lambda})}{\lambda}| \cdot \sigma(\lambda) === \frac{ln(2) \cdot \sigma(\lambda)}{\lambda ^ {2}}$$

$$\sigma(\lambda) = `r summaryForModelForActivity$coefficients[2, 2]`$$

```{r}
sigmaTauForActivity = log(2) * summaryForModelForActivity$coefficients[2, 2] / lambda ^ 2;
sigmaTauForActivity
```

$$\sigma(\tau) = `r sigmaTauForActivity`$$

```{r}
numberOfTestsForActivity = length(timeForActivity)
numberOfTestsForActivity
library(distributions3)
studentTDistributionForActivity = StudentsT(df = numberOfTestsForActivity - 1)
studentTDistributionForActivity
probabilitiesForActivity = 1 - .05 / 2
probabilitiesForActivity
studentTFactorForActivity = quantile(studentTDistributionForActivity, probabilitiesForActivity)
studentTFactorForActivity
```

$$\Delta(\tau) = `r sigmaTauForActivity * studentTFactorForActivity / sqrt(numberOfTestsForActivity)`$$

## Keemilise reaktsiooni kiirus

3Keemilise reaktsiooni kiirus *R* (iseloomustab mitu grammi uut ühendit aja jooksul tekib) sõltub metalli kontsentratsioonist *n* järgmiselt: *R=A*n^3^+B\*n^2^+C*n* (tegemist on polünoomiga, mitte lineaarse sõltuvuse graafikuga!). Mõõtmistulemused on toodud alltoodud tabelis. joonistada sõltuvuse graafik koos mõõtemääramatustega, sobitada ülaltoodud funktsiooni graaikule ning leida suurused *A* ja *B*. Kas antud andmed kinnitavad antud seose kehtivust? Mille põhjal võib seda võita?

```{r}
n = c(9, 12, 15, 18, 21, 24, 27)
r = c(.12, .22, .34, .5, .72, 1.1, 1.55)
reactions = data.frame(n = n, r = r)
colnames(reactions) = c("$n \\pm2 (g/m^{3})$", "$R\\pm.02 (g/s)$")
library(kableExtra)
reactions %>% kbl(caption = "Keemilise reaktsiooni kiirused") %>% kable_styling(bootstrap_options = c("striped", "hover"))
formulaForReactions = r ~ I(n ^ 3) + I(n ^ 2) + n
modelForReactions = lm(formula = formulaForReactions, data = reactions)
summaryForModelForReactions = summary(modelForReactions)
summaryForModelForReactions
library(ggplot2)
library(ggpmisc)
ggplot(data = reactions, mapping = aes(x = n, y = r)) +
  labs(x = "$n \\pm2 (g/m^{3})$", y = "$R\\pm.02 (g/s)$") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = formulaWithForced0) +
  stat_poly_eq(eq.with.lhs = "r~`=`~", eq.x.rhs = "~n", aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), parse = TRUE, formula = formulaForReactions) +
  #stat_function(fun = function (xForPendulum) kWithForced0 * xForPendulum, color = "red") +
  annotation_logticks(sides ="lr")+
  #scale_x_log10() 
  #scale_y_log10()
  geom_errorbar(aes(ymin = r - .02, ymax = r + .02)) +
  geom_errorbarh(aes(xmin = n - 2, xmax = n + 2))

```

## Hapniku taseme saavutamine

Vees hapniku taseme saavutamine Lõuna-Soome järvedes (J. Vesterinen, S.P. Devlin jt. Influence of littoral periphyton on whole-lake metabolism relates to littoral vegetation in humic lakes. Ecology, 98, 2017, 3074-3085)

```{r}
lake = c("Mekkojärvi", "Horkkajärvi", "Huhmari", "Möläkkä", "Nimetön", "Tavilammi", "Keskinen Rajajärvi", "Haukijärvi")

production = c(42, 95, 70, 75, 35, 60, 25, 42)
sdForProduction = c(30, 20, 15, 20, 15, 10, 10, 10)

oxygen = data.frame(lake = lake, production = production, sdForProduction = sdForProduction)
colnames(oxygen) = c("Järv", "Pelaafiline rimaarne O netotootmine/SD (mg C m^(-3) d^(-1)", "SD")
library(kableExtra)
oxygen %>% kbl(caption = "Hapniku tootmine") %>% kable_styling(bootstrap_options = c("striped", "hover"))
library(ggplot2)
library(ggpmisc)
ggplot(data = oxygen, mapping = aes(x = production)) +
  #geom_bar(stat="identity", width=.5, fill="tomato3") + 
  labs(title="Hapniku tootmine", 
       subtitle="Soome", 
       caption="järved", x = "Järv", y = "Pelaafiline rimaarne O netotootmine/SD (mg C m^(-3) d^(-1)") + 
  theme(axis.text.x = element_text(angle=65, vjust=0.6)) +
  #geom_point() +
  #geom_line() +
  #ylim(6, NA) +
  #geom_smooth() +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = formulaWithForced0) +
  #stat_poly_eq(eq.with.lhs = "r~`=`~", eq.x.rhs = "~n", aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), parse = TRUE, formula = formulaForReactions) +
  #stat_function(fun = function (xForPendulum) kWithForced0 * xForPendulum, color = "red") +
  annotation_logticks(sides ="lr")
  #scale_x_log10() 
  #scale_y_log10()
  #geom_errorbar(aes(ymin = r - .02, ymax = r + .02)) +
  #geom_errorbarh(aes(xmin = n - 2, xmax = n + 2))

```

## Virutaalne labor

(Matemaatilise) pendli vabavõnkumiste periood ehk aeg täisvõnke tegemiseks on seotud pendli pikkusega järgmiselt: $T = 2 * \pi * \sqrt{\frac{L}{g}}$, kus *L* on pendli pikkus meetrites ning *g* on vaba langemise kiirendus. Antud seos on üks võimalusi vaba langemise kiirenduse ehk raskuskiirenduse määramiseks. Kasutage [Phet-i simulatsiooni raskuskiirenduse määramiseks](http://phet.colorado.edu/sims/html/pendulum-lab/latest/pendulum-lab_en.html)

Selleks:

- Valige Lab, sellelt mõõteseadmeks Period Timer (mis mõõdab otseselt perioode). Pendli massiks võib olla 1 kg. Hõõrdumine (Friction) tuleb ise valida ja ei tohi olla 0.

- Leidke pendli võnkeperioodid (iga pikkuse kohta 5 katset) 6-8 erineva pendli pikkuse korral, tulemused kandke alljärgnevasse tabelisse

```{r}
lForPendulumInPhet = c(.7, .5, .3, .1, .8, 1)
tsForPendulumInPhet = list(list(1.7476, 1.6926, 1.6889, 1.6874, 1.686), list(1.4225, 1.422, 1.4216, 1.4213, 1.421), list(1.1014, 1.1011, 1.1009, 1.1007, 1.1005), list(.6354, .6353, .6352, .6352, .6351), list(1.7948, 1.7948, 1.7947, 1.7947, 1.7946), list(2.0064, 2.0064, 2.0063, 2.0063, 2.0063))
listForPendulumInPhet <- list(lForPendulumInPhet, tsForPendulumInPhet,c(1,2,3,4), FALSE, list(1,2,3,4,5,6))
#colnames(listForPendulumInPhet) <- c("Pikkus", "Perioodid")
#matrixForPendulumInPhet[.7, c("B", "A")]
matrixForPendulumInPhet <- matrix(ncol = 2, byrow = FALSE, c(
  .7, c(1.7476, 1.6926, 1.6889, 1.6874, 1.686),
  .5, c(1.4225, 1.422, 1.4216, 1.4213, 1.421),
  .3, c(1.1014, 1.1011, 1.1009, 1.1007, 1.1005),
  .1, c(.6354, .6353, .6352, .6352, .6351),
  .8, c(1.7948, 1.7948, 1.7947, 1.7947, 1.7946),
  1, c(2.0064, 2.0064, 2.0063, 2.0063, 2.0063)
))
matrixForPendulumInPhet

xForPendulumInPhet = sapply(lForPendulumInPhet, sqrt)
tForPendulumInPhet = sapply(tsForPendulumInPhet, mean)
#sigmaForPendulumInPhet = sapply(tsForPendulumInPhet, sd)
#pendulumInPhet = data.frame(lForPendulumInPhet = lForPendulumInPhet, xForPendulumInPhet = xForPendulumInPhet, tForPendulumInPhet = tForPendulumInPhet, sigmaForPendulumInPhet = sigmaForPendulumInPhet)
#colnames(pendulumInPhet) = c("L(m)", "$x=sqrt(L) (m^{\\frac{1}{2}})$", "T_kesk(s)", "σ_T")
library(kableExtra)
#pendulumInPhet %>% kbl(caption = "Virtuaalne labor") %>% kable_styling(bootstrap_options = c("striped", "hover"))

```

Joonistage Excelis või LibreOffice Calcis graafik T sõltuvus $\sqrt{L}$-st ning sobitades lineaarse seosega leidke sirge tõus *k*. Et $k = \frac{2 * \pi}{\sqrt{g}}$, saab leida *k* abil *g*. Leidke *g* ning hinnake, kui palju see erineb aktsepteeritud väärtusest, mis on saadud juhul, kui õhutakistus on 0.

