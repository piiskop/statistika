---
title: "Regression"
author: 'peacecop kalmer:'
date: "11/9/2021"
output:
  html_document:
    md_extensions: +link_attributes
    toc: TRUE
    toc_float: TRUE
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Vaskjuhe

```{r cars}
temperatures = c(8, 16.5, 23.5, 32, 40.4, 54.5)
resistancies = c(0.208, 0.213, 0.222, 0.229, 0.232, 0.243)
temperaturesAndResistancies = data.frame(temperatures = temperatures, resistancies = resistancies)
statsForTemperaturesResistancies = lm(formula = resistancies ~ temperatures, data = temperaturesAndResistancies)
summary(statsForTemperaturesResistancies)
plot(temperaturesAndResistancies$temperatures, temperaturesAndResistancies$resistancies)
abline(statsForTemperaturesResistancies)
```

## xy

```{r xy}
x = c(1:5)
y = c(2.1, 3.5, 5.4, 6.2, 8.1)
sizeOfData = length(x)
sizeOfData
sumOfX = sum(x)
sumOfX
sumOfXY = sum(x*y)
sumOfXY
sumOfY = sum(y)
sumOfY
sumOfSquaredX = sum(x ^ 2)
sumOfSquaredX
slopeManually = (sizeOfData * sumOfXY - sumOfX * sumOfY) / (sizeOfData * sumOfSquaredX - sumOfX ^ 2)
slopeManually
interceptManually = (sumOfSquaredX * sumOfY - sumOfX * sumOfXY) / (sizeOfData * sumOfSquaredX - sumOfX ^ 2)
interceptManually
xy = data.frame(x = x, y = y)
statsForXY = lm(formula = y ~ x, data = xy)
summary(statsForXY)
library("ggpubr")
ggscatter(xy, x = "x", y = "y", add = "reg.line", conf.int = TRUE, cor.coef = TRUE, cor.method = "pearson", xlab = "x", ylab = "y")
shapiro.test(xy$x)
shapiro.test(xy$y)
ggqqplot(xy$x, ylab = "x")
ggqqplot(xy$y, ylab = "y")
resultOfPearsonCorrelationTest = cor.test(xy$y, xy$x, method = "pearson")
resultOfPearsonCorrelationTest
resultOfPearsonCorrelationTest$estimate
```
## Sademed

```{r}
temperatures = c(195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210)
radarRainRate = c(150, 150, 150, 118, 109, 95, 63, 66, 44, 29, 29, 35, 38, 31, 20, 24)
precipitants = data.frame(temperature = temperatures, rainRate = radarRainRate)
#plot(x = precipitants$temperature, y = precipitants$rainRate, type = "o", main = "Vihma intensiivsus", xlab = "Temperatuur (K)", ylab = "Vihma hulk (mm / h)")
ggplot(data = precipitants, mapping = aes(x = temperature, y = rainRate)) +
  xlim(180, 230) +
  geom_point() +
  geom_smooth() +
  labs(title = "Vihma intensiivsus", x = "Temperatuur (K)", y = "Vihma hulk (mm / h)") +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")))
statsForPrecipitation = lm(formula = rainRate ~ temperature, precipitants)
summaryForPrecipitation = summary(statsForPrecipitation)
summaryForPrecipitation
```

Vihma hulga muutumise kiirus (mm / h / K) on `r round(summaryForPrecipitation$coefficients[2, 1], digits = 1)`.

Nulltemperatuuri korral võiks mudeli järgi olla vihma (mm / h) `r round(summaryForPrecipitation$coefficients[1, 1], digits = 1)`.

Temperatuur, mille korral 0 mm / h sademeid: `r round(abs(summaryForPrecipitation$coefficients[1, 1] / summaryForPrecipitation$coefficients[2, 1]), digits = 1)` K.

Pearsoni koefitsient: `r cor.test(precipitants$rainRate, precipitants$temperature, method = "pearson")$estimate`

Milline on mudeli põhjal vihma tugevus pilve temperatuuril 230 ja 180 K?

230 K korral on vihma tugevus `r round(summaryForPrecipitation$coefficients[2, 1] * 230 + summaryForPrecipitation$coefficient[1, 1], digits = 1)` mm / h.

180 K korral on vihma tugevus `r round(summaryForPrecipitation$coefficients[2, 1] * 180 + summaryForPrecipitation$coefficient[1, 1], digits = 1)` mm / h.

## Hõbedalahus

```{r}
concentration = c(0, 5, 10, 15, 20, 25, 30)
absorbance = c(0.02, 0.13, 0.25, 0.39, 0.5, 0.62, 0.76)
solution = data.frame(concentration = concentration, absorbance = absorbance)
model0 = lm(absorbance ~ 0 + concentration, solution)
ggplot(data = solution, mapping = aes(x = concentration, y = absorbance)) +
  labs(title = "Valge valguse neelduvus lahuses", x = "Lahuse kontsentratsioon (ng / ml) +/- .25 (ng / ml)", y = "Neelduvus (suhtelised ühikud) +/- 5 % näidust") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  geom_abline(intercept = 0, slope = coef(model0)[1], color = 3) +
  geom_errorbar(aes(ymin = absorbance * .95, ymax = absorbance * 1.05)) +
  geom_errorbarh(aes(xmin = concentration - .25, xmax = concentration + .25))
statsForSolution = lm(formula = absorbance ~ concentration, solution)
summaryForSolution = summary(statsForSolution)
summaryForSolution
```

tõus: `r round(summaryForSolution$coefficients[2, 1], digits = 3)`

*y*-teljega lõikumise koht: `r round(summaryForSolution$coefficients[1, 1], digits = 3)`

## Fotodiood

Fotodioodi pinge sõltuvus temperatuurist on toodud järgnevas tabelis.

Joonistada graafikule sõltuvuse graafik koos veakastidega. Pinge mõõtemääramatuse leidmiseks tuleb arvestada, et mõõtmisi on sooritatud digitaalse mõõteriistaga, mille täpsus on 5%.

Sellest saab leida piirihälbe ning seejärel mõõtemääramatuse 95 % usaldatavuse korral.

Eeldades, et pinge sõltub temperatuurist lineaarselt, leida lineaarse regressiooni parameetrid koos veahinnanguga.

```{r}
temperature = c(2, 10, 19, 26.5, 40.5, 49, 59.5, 65, 80, 91.5, 101.5)
voltage = c(0.686, 0.662, 0.6375, 0.614, 0.59, 0.5415, 0.5175, 0.494, 0.4698, 0.4697, 0.4462)
dataAboutVoltage = data.frame(temperature = temperature, voltage = voltage)
statsForVoltage = lm(formula = voltage ~ temperature, dataAboutVoltage)
summaryForVoltage = summary(statsForVoltage)
summaryForVoltage
library(distributions3)
numberOfTests = length(voltage)
studentTDistribution = StudentsT(df = numberOfTests - 1)
halfSuccess = .95 / 2
studentTFactor = quantile(studentTDistribution, halfSuccess)
studentTFactorForInfinity = quantile(StudentsT(df = Inf), halfSuccess)
uncertainty = sqrt((sd(voltage) / sqrt(numberOfTests) * studentTFactor) ^ 2 + (.05 * mean(voltage) * studentTFactorForInfinity / 3) ^ 2 + (halfSuccess * .0001) ^ 2)
```

tõus: `r round(summaryForVoltage$coefficients[2, 1], digits = 4)`

*y*-teljega lõikumise koht: `r round(summaryForVoltage$coefficients[1, 1], digits = 4)`

```{r}
ggplot(data = dataAboutVoltage, mapping = aes(x = temperature, y = voltage)) +
  labs(title = "Fotodioodi pinge sõltuvus temperatuurist", x = "T (°C)", y = "U (V)") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  geom_errorbarh(aes(xmin = temperature - .5, xmax = temperature + .5)) +
  geom_errorbar((aes(ymin = voltage - uncertainty, ymax = voltage + uncertainty)))
```

## Lõuna-Šotimaa

Järgnevas tabelis on toodud Lõuna-Šotimaal erinevates kohtades mõõdetud aastane sademete hulk ning vastav mõõtemääramatus. Ülesanne - luua andmete põhjal graafik, millele on märgitud ka mõõtemääramatused. Koostada lineaarse regressiooni mudel.

```{r}
place = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
height = c(240, 420, 470, 300, 150, 460, 410, 140, 540, 280, 200, 160, 270, 230)
precipitationsInYear = c(1720, 2050, 1870, 1690, 1250, 2090, 2040, 1460, 1860, 1670, 1490, 900, 1250, 1170)
measurementUncertaintyForPrecipitationsInyear = c(50, 70, 70, 100, 50, 100, 70, 70, 120, 70, 50, 50, 70, 50)
precipitations = data.frame(place = place, height = height, precipitationsInYear = precipitationsInYear, measurementUncertaintyForPrecipitationsInyear = measurementUncertaintyForPrecipitationsInyear)
colnames(precipitations) = c("Koha nr", "Kõrgus merepinnast (m)", "Sademete hulk (mm/aastas)", "Mõõtemääramatus sademete hulga jaoks (mm/aastas)")
library(kableExtra)
precipitations %>% kbl(caption = "Lõuna-Šotimaa sademed") %>% kable_styling(bootstrap_options = c("striped", "hover"))
modelForPrecipitations = lm(precipitationsInYear ~ height, precipitations)
modelForPrecipitations
modelForPrecipitations$coefficients[1]
ggplot(data = precipitations, mapping = aes(x = height, y = precipitationsInYear)) +
  labs(x = "Kõrgus merepinnast (m)", y = "Sademete hulk (mm/aastas)") +
  geom_point() +
  geom_line() +
  geom_abline(intercept = modelForPrecipitations$coefficients[1], slope = modelForPrecipitations$coefficients[2], color = 3) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  geom_errorbar((aes(ymin = precipitationsInYear - measurementUncertaintyForPrecipitationsInyear, ymax = precipitationsInYear + measurementUncertaintyForPrecipitationsInyear)))
summaryForPrecipitations = summary(modelForPrecipitations)
summaryForPrecipitations
```

## Neeldumine

On antud spektroskoopilised neeldumiskõverad - neeldumise sõltuvus albumiini võ glütsiini kontsentratsioonist. Skitseerida mõlema juhu jaoks lineaarse regressiooni graafikud ning ruutsõltuvuse (2. järku polünoomi) graafikud. Juhul, kui lineaarne sõltuvus sobib, leida lineaarse mudeli parameetrite puhul ka intercept'i ja slope'i standardhälbed. Lisaküsimus - kuidas lisada graafikule veakastid ja millised veakastid peaksid siin olema?

```{r}
concentration = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
absorbance = c(0, 80.33, 135.7, 207, 243.3, 303, 329, 370.3, 406, 431.7, 444.3)
albumin = data.frame(concentration = concentration, absorbance = absorbance)
modelForAlbumin = lm(formula = absorbance ~ -1 + I(concentration ^ 2) + concentration, data = albumin)
modelForAlbumin
linearModelForAlbumin = lm(formula = absorbance ~ concentration, data = albumin)
linearModelForAlbumin
summaryForAlbumin = summary(linearModelForAlbumin)
summaryForAlbumin
ggplot(data = albumin, mapping = aes(x = concentration, y = absorbance)) +
  labs(x = "Kontnsentratsioon c", y = "Neelduvus N") +
  geom_point() +
  geom_line() +
  geom_smooth(method = "lm", formula = y ~ -1 + x, fill = "orange") +
  geom_smooth(method = "lm", formula = y ~ -1 + I(x ^ 2) + x, fill = "firebrick") +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = y ~ -1 + x, label.x = 3, label.y = 34) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = y ~ -1 + I(x ^ 2) + x)
```

Suvalist [regressioonigraafikut saab arvutada ka käsitsi](http://polynomialregression.drque.net/math.html). See oleks huvitav kunagi läbi teha.

## Takistused

Pooljuhi takistus on läbi pooljuhi mineva voolu tugevuse funktsioon *R=f(I)*. Eeldame, et see seos on järgmine: $R=k\cdotI^{n}$. Joonistada graafik, logaritmiline graafik. Leida konstandid *k* ja *n*.

```{r}
i = c(.001, .002, .004, .008, .016, .032, .064, .13, .26, .52)
r = c(.0006, .0022, .0063, .02, .042, .12, .34, 1.1, 3.2, 9.5)
resistancies = data.frame(i = i, r = r)
colnames(resistancies) = c("I(A)", "R(Ω)")
resistancies %>% kbl(caption = "Takistused") %>% kable_styling(bootstrap_options = c("striped", "hover"))
modelForResistancies = lm(log(r) ~ log(i))
summary(modelForResistancies)
ggplot(data = resistancies, mapping = aes(x = i, y = r)) +
  labs(x = "I(A)", y = "R(Ω)") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  scale_x_log10(limits = c(1e-3, 1)) +
  scale_y_log10(limits = c(1e-4, 10)) +
  theme_bw() +
  annotation_logticks() +
  stat_function(fun = function (x) exp(coef(modelForResistancies)[1]) * x ^ coef(modelForResistancies)[2], color = "red")
```

*k*: `r exp(coef(modelForResistancies)[1])`

*n*: `r coef(modelForResistancies)[2]`

## Poollogaritmika

Tabelis on toodud andmed seose $z=a*10^{b*x}$. Leida konstandid *a* ja *b* ning joonistada graafik tavalises ja poollogaritmilises teljestikus.

```{r}
x = c(.1, .2, .4, .6, 1, 1.5, 1.8, 2, 2.2, 2.5, 3.2, 4)
z = c(2.4, 2.75, 3, 3.4, 4.1, 5.7, 6.8, 7.5, 8.8, 10.1, 15, 24)
halfLogarithmics = data.frame(x = x, z = z)
halfLogarithmics %>% kbl(caption = "Poollogaritmika") %>% kable_styling(bootstrap_options = c("striped", "hover"))
modelForHalfLogarithmics = lm(log(z) ~ x)
modelForHalfLogarithmics
summaryForModelForHalfLogarithmics = summary(modelForHalfLogarithmics)
summaryForModelForHalfLogarithmics
ggplot(data = halfLogarithmics, mapping = aes(x = x, y = z)) +
  labs(x = "x", y = "z") +
  geom_point() +
  geom_line() +
  geom_smooth() +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = log(z) ~ x)+
  labs(title = paste()) +
  stat_function(fun = function (x) exp(coef(modelForHalfLogarithmics)[1]) * exp(coef(modelForHalfLogarithmics)[2]) * x, color = "red") +
  annotation_logticks() +
  scale_y_log10(limits = c(1, 100))
```

$$z=`r round(exp(modelForHalfLogarithmics$coefficients[1]), digits = 4)`*10^{`r round(modelForHalfLogarithmics$coefficients[2], digits = 4)`*x}$$

$$R^{2}=`r summaryForModelForHalfLogarithmics$r.squared`$$

## CaCO

Tabelis on toodud süsteemi - CaCO tahkis-vedelik-gaas tasakaalulised kontsentratsioonid ja vedeliku happelisuse tasemed. Teha a) graafik I veerg vs viimane veerg, b) teine veerg vs viimane veerg. Tavalises ja poollogaritmilises teljestikus. Leida võimalusel sobiv fit-funktsioon. Üks võte numbrite sisestamisel. Nt 8.08*10^-7 on tabelis kujul 9.08E-07 ning 2.37*10^4 on kujul 2.37E04

```{r tableForSolidFluidGas}
ppmCo2 = c(0.000000808, 0.0000255, 0.000295, 0.00295, 0.0295, 0.295, 0.692, 2.95, 29.5, 88.5, 295, 390, 885, 2950, 23700)
mmolLCo2 = c(2.74E-11, 8.66E-10, 0.00000001, 0.0000001, 0.000001, 0.00001, 0.0000235, 0.0001, 0.001, 0.003, 0.01, 0.0132, 0.03, 0.1, 0.802)
mmolLCox = c(0.000566, 0.00187, 0.00455, 0.0111, 0.029, 0.0748, 0.103, 0.173, 0.375, 0.541, 0.812, 0.893, 1.19, 1.82, 4.25)
mmolLCa = c(5.05, 1.6, 0.71, 0.33, 0.17, 0.11, 0.1, 0.12, 0.2, 0.28, 0.41, 0.44, 0.58, 0.86, 1.73)
pH = c(12, 11.5, 11.15, 10.81, 10.46, 10.06, 9.88, 9.54, 8.92, 8.61, 8.27, 8.19, 7.95, 7.6, 7)
solidFluidGas = data.frame(ppmCo2 = ppmCo2, mmolLCo2 = mmolLCo2, mmolLCox = mmolLCox, mmolLCa = mmolLCa, pH = pH)
colnames(solidFluidGas) = c("$P(CO_{2})_{G}, ppm$", "$[CO_{2}]_{W}, mmol/L$", "$\\sum[CO_{X}]_{W}, mmol/L$", "$[Ca^{2+}], mmol/L$", "pH")
solidFluidGas %>% kbl(caption = "Equilibrium concentrations of $[CO_{2}]_{W}$, $HC_{3}^{-}$, and $Ca^{2+}$ and pH in the system of gas-water-solid $CaCO_{3}$ at $t = 25 °C$. Boldface designates extremal of $Ca^{2+}$ and $CO_{3}^{2-}$ at $[CO_{2}]_{W}\\cong2.35\\times10^{-5} mmol/L$") %>% kable_styling(bootstrap_options = c("striped", "hover")) %>% row_spec(7, bold=T)
modelForCo2 = lm(pH ~ log(mmolLCo2))
modelForCo2
summaryForModelForCo2 = summary(modelForCo2)
summaryForModelForCo2
ggplot(data = solidFluidGas, mapping = aes(x = mmolLCo2, y = pH)) +
  labs(x = "CO2/mmol/L", y = "pH") +
  geom_point() +
  geom_line() +
  ylim(6, NA) +
  annotation_logticks(sides ="tb") +
  scale_x_log10(limits = c(.00000000001, 1))
```

pH sõltuvus CO_2_'st:

$$z=`r round(modelForCo2$coefficients[2], digits = 4)`*ln(x)+{`r round(modelForCo2$coefficients[1], digits = 4)`}$$

$$R^{2}=`r summaryForModelForCo2$r.squared`$$

```{r}
modelForCox = lm(pH ~ log(mmolLCox))
modelForCox
summaryForModelForCox = summary(modelForCox)
summaryForModelForCox
ggplot(data = solidFluidGas, mapping = aes(x = mmolLCox, y = pH)) +
  labs(x = "COx/mmol/L", y = "pH") +
  geom_point() +
  geom_line() +
  ylim(6, NA) +
  stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  scale_x_log10(limits = c(.0001, 10))

```

pH sõltuvus CO_X_'st:

$$z=`r round(modelForCox$coefficients[2], digits = 4)`*ln(x)+{`r round(modelForCox$coefficients[1], digits = 4)`}$$

$$R^{2}=`r summaryForModelForCox$r.squared`$$

```{r}
ggplot(data = solidFluidGas, mapping = aes(x = mmolLCa, y = pH)) +
  labs(x = "Ca2+/mmol&L", y = "pH") +
  #geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")))
  #stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10(limits = c(.0001, 10))

```

## Eksponentsiaalne sõltuvus

### Ülesande püstitus

Leida järgnevatest kaks andmerida:

- inimkonna arvukuse kasv

- nafta kulutamine (aastas)

- energia kulutamine (aastas)

- CO2 aastane emissioon (aastas)

kogu maailma kohta.

Teha nende kahe valitud andmejada kohta graafikud ning leida eksponentsiaalse sõltuvuse funktsioonid graafiku järgi (Trendline abil).

Teha nende kahe andmejada kohta korrelatsioonanalüüs - näiteks CO-2 y-teljel ja nafta kulutamine x-teljel.

Tuleb arvestada, et nt nafta tootmine või CO2 emissioon hakkas eksponentsiaalselt kasvama alles industriaalajastuga, siis peaks aja jaoks tegema ümber arvutuse. Nt tähistama aasta 1900 0-ks. 1910 oleks siis aasta 10 jne.

### Algandmed

```{r}
year = c(1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020)

population=c(2536431,2584034,2630862,2677609,2724847,2773020,2822443,2873306,2925687,2979576,3034950,3091844,3150421,3211001,3273978,3339584,3407923,3478770,3551599,3625681,3700437,3775760,3851651,3927781,4003794,4079480,4154667,4229506,4304534,4380506,4458003,4536997,4617387,4699569,4784012,4870922,4960568,5052522,5145426,5237441,5327231,5414289,5498920,5581598,5663150,5744213,5824892,5905046,5984794,6064239,6143494,6222627,6301773,6381185,6461159,6541907,6623518,6705947,6789089,6872767,6956824,7041194,7125828,7210582,7295291,7379797,7464022,7547859,7631091,7713468,7794799)

co2Emissions = c(5998250390, 6374254691, 6460339682, 6641273014, 6784215194, 7436238817, 7917168948, 8178702419, 8411438653, 8847900121, 9359426482, 9388244087, 9719779635, 10239773013, 10793877121, 11282700958, 11829640492, 12205845914, 12871319383, 13724862841, 14853217232, 15453605261, 16173079951, 17027165013, 16957206737, 16999328068, 17933956104, 18444838983, 19016691375, 19557553854, 19444411140, 18980238345, 18830746953, 18949762962, 19604480685, 20262211219, 20559974625, 21191788543, 22012236539, 22320123319, 22749574361, 23238102148, 22569624280, 22803495350, 22964583360, 23453944453, 24154961205, 24300550431, 24206271270, 24518962289, 25234207250, 25451054499, 26039191478, 27366723290, 28627533035, 29602777195, 30583530082, 31493741589, 32069444008, 31607042411, 33343300453, 34468451046, 34974075146, 35283025442, 35534442951, 35496406338, 35452459300, 35925737688, 36646139785, 36702502902, 34807259099)

world = data.frame(year = year, population = population, co2Emissions = co2Emissions)
library(htmltools)
colnames(world) = c("Aasta", "Tuhat inimest [@people]", '$CO_{2}$ emissioone (t / y) [@owidenergy]')

world %>% kbl(caption = "Maailma inimeste arv ja süsinikdioksiidi aastane emissioon aastates 1950 - 2020 seisuga 20211120", longtable = T, booktabs = T) %>% kable_styling(bootstrap_options = c("striped", "hover"), latex_options = c("repeat_header"))
```

### Lahendus

```{r}
ggplot(data = world, mapping = aes(x = population, y = co2Emissions)) +
labs(x = "Tuhat inimest", y = bquote(CO[2] ~ 'emissioone (t / y)')) +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = co2Emissions ~ population)
  #stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10(limits = c(.0001, 10))
modelForWorld = lm(co2Emissions ~ population)
summaryForModelForWorld = summary(modelForWorld)
summaryForModelForWorld
```

Inimeste arvu suurenemine maailmas ja süsinikdioksiidi heitmete suurenemine maailmas oli aastail 1950 - 2020 tugevas lineaarses seoses. Kuna seos on lineaarne, siis pole mõtet aretada eksponentsiaalset graafikut.

Uurin eraldi sõltuvust inimeste populatsiooni ja aja vahel:

```{r}
ggplot(data = world, mapping = aes(x = year, y = population)) +
labs(x = "Aasta", y = "Tuhat inimest") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = population ~ year)
  #stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10(limits = c(.0001, 10))
modelForPopulation = lm(population ~ year)
summaryForModelForPopulation = summary(modelForPopulation)
summaryForModelForPopulation

```

Inimeste arvu suurenemine on otseses sõltuvuses ajakulgust. Kuna inimeste arvu kasv on otseses sõltuvuses aja kulgust ja inimeste arvuga korreleerub tugevasti süsinikdioksiidi heitmete mass, siis on järelikult ka vähemalt tugev lineaarne sõltuvus aja kulgu ja süsinikdioksiidi heitmete massi vahel. Nii et valitud andmeridade vahel ei ole eksponentsiaalset seost.

Kui surfata lehel, kust pärinevad süsinikdioksiidi heitmete arvud [@owidenergy], leiame sealt graafiku energiatarbimise kohta, mis ei erine käsitletavas ajavahemikus teistest käsitletud graafikutest - korrelatsioon on tugevalt lineaarne ajaga. Sama paistab ka fossiilsete kütuste tarbimise kohta.

Võiks muidugi võtta pikema ajavahemiku ja nautida näiliselt eksponentsiaalset seost. Ometi oleks see petlik, sest kuigi graafikute tõus on enne 1950. aastat oluliselt väiksem, tähendab see siiski vaid n-ö käivitusaega ja kui juba käivitamine on toimunud, on kulgemine toimunud lineaarselt. See üllatab mind, sest arvasin ka varem, et rahvaarv kasvab eksponentsiaalselt. Selgus, et see polegi nii.

### Arutelu õpetajaga

Ajaperiood ongi liiga lühike. Eksponentsiaalne kasv eeldab piiramatuid resursse. Või piiramatult kasutusele võetavaid resursse. Lühikest ajaperioodi saab alati lineaarse kasvuga sobitada. Ja eksponentfunktsiooni graafikut saab alati mingis ajaperioodis lineaarsega lähendada.
Ning seaduste, reeglitega nt rahvaarvu kasvu piirata. Või sõdadega. Või suurendada, nt antibiootikumide kasutuselevõtt tõstis inimeste arvukuse kasvamise kiirust oluliselt.
Aga võttes aluseks nt inimkonna arvukuse modelleerimisel või matemaaeksponentsialse kasvu vs lineaarne, sõltub sellest, millest on inimeste arvu kasv tingitud.
Eksponentsiaalne kasv on juhul kui varusid on piiramatult ning aastas juurdetulevate inimeste arv sõltub olemasolevate arvust. Nt iga miljoni inimese kohta 1000 inimest juurde, seega 10 miljoni kohta 10000 inimest juurde, 1 miljardi kohta aastas juurdekasv 1 miljon. Jne.
Lineaarne kasv arvestab, et juurdesündivate inimeste arv ei sõltu olemasolevate arvust. See võiks juhtuda kui varusid on piiratud või pannakse mingiks ajaperioodiks paika reeglid, mille rakendamisel surutakse inimeste arvu kasv maha. Kui nt Eestis iive on null, siis sobib lineaarse kasvu mudel väga hästi. Eksponentsiaalse oma sobiks siis kah.

Demograafia tegeleb eraldi nende faktoritega erinevates rikides, maailmajagudes ja maailmas tervikuna.

Parimat,
Tõnu Laas

On Sat, Nov 20, 2021 at 10:56 PM peacecop kalmer: <kalmer@test.tennis24.ee> wrote:
Tegin analüüsi ära. Kõige enam aega kulus algandmete otsimisele ja mõningate tehniliste lahenduste otsimisele, mis puudutab "Bookdown"'i "RStudio"'s. Palun vaata mu lahendust aadressilt http://statistika.tennis24.ee/regression.html#Eksponentsiaalne_s%C3%B5ltuvus Ülesande lahendus on lehe lõpuosas. Vasakult menüüst saad valida "Eksponentsiaalse sõltuvuse". Võiksid pilgu ka "Poollogaritmikale" ja "CaCO"'le peale visata, et kas need tulemis on sellised, nagu sa ootasid.

Mul pole mõtet mitte ühtki faili üles laadida, kuna kõik on seal lehel näha ja ma ei püüdnudki tabelarvutusprogrammis sellega seekord tegeleda.

Ei tule kuidagi realistlikku eksponentsiaalset seost nende andmetega, kui me just end ei peta. Eksponentsiaalne seos tähendaks, et ka nt ajavahemikus 2000 - 2020 iga aasta kohta suurenes miski järjest rohkem. Aga tuli välja, et suurenes alati ühepalju. Muidugi võiks arendada mingi multigraafiku, mille algus on eksponentsiaalne, praegune osa lineaarne, ometi kui midagi ennustada, siis pigem lineaarse jupi alusel, mis on juba 70 aastat püsinud.

### Täiendatud algandmed

Kuna maailma rahvaarvu kohta pole nii täpseid andmeid 1950. aastast varasema aja kohta kui alates 1950. aastast, käsitlen täiendatud algandmeid alates aastast 1750 intervalliga 50 aastat:

```{r}
year1 = c(1750, 1800, 1850, 1900, 1950, 2000)

population1=c(814000, 990000, 1263000, 1654000, 2536431, 6143494)

co2Emissions1 = c(9350528, 28091888, 196896032, 1952224654, 6003238189, 25234207250)

world1 = data.frame(year = year1, population = population1, co2Emissions = co2Emissions1)
library(htmltools)
colnames(world1) = c("Aasta", "Tuhat inimest [@people] [@population]", '$CO_{2}$ emissioone (t / y) [@owidenergy] [@co2')

world1 %>% kbl(caption = "Maailma inimeste arv ja süsinikdioksiidi aastane emissioon aastates 1750 - 2020 seisuga 20211121", longtable = T, booktabs = T) %>% kable_styling(bootstrap_options = c("striped", "hover"), latex_options = c("repeat_header"))
```

### Lahendus täiendatud algandmetega

```{r}
ggplot(data = world1, mapping = aes(x = population1, y = co2Emissions1)) +
  labs(x = "Tuhat inimest", y = bquote(CO[2] ~ 'emissioone (t / y)')) +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth()
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = co2Emissions1 ~ population1) 
  #stat_function(fun = function (x) coef(modelForCox)[2] * log(x) + coef(modelForCox)[1], color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10() 
  #scale_y_log10()
modelForWorld1 = lm(co2Emissions1 ~ population1)
summaryForModelForWorld1 = summary(modelForWorld1)
summaryForModelForWorld1
```

Nagu graafikult näha, ei olnud perioodi pikendamine abiks ja graafik kinnitab mu eelnevat juttu, et jalgrattaga sõitma hakates toimub kiirendamine aeglasemalt, misjärel kiiremini, misjärel on kiirus ühtlane. Kui muuta see graafik logaritmiliseks, ei teki lineariseeritust.

Uurin eraldi sõltuvust inimeste populatsiooni ja aja vahel:

```{r}
modelForPopulation1 = lm(log(population1) ~ year1)
ggplot(data = world1, mapping = aes(x = year1, y = population1)) +
  labs(x = "Aasta", y = "Tuhat inimest") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = log(population1) ~ year1) +
  stat_function(fun = function (x) exp(coef(modelForPopulation1)[1]) * exp(coef(modelForPopulation1)[2] * x), color = "red") +
  #annotation_logticks(sides ="tb") +
  #scale_x_log10() 
  scale_y_log10()
summaryForModelForPopulation1 = summary(modelForPopulation1)
summaryForModelForPopulation1
```

R ruudus on .91, kui lineariseerida graafik selliselt, et ordinaattelg logaritmida. Seega on seos aja kulgu ja inimeste hulga suurenemise vahel maailmas niimoodi tugev.

Uurin eraldi sõltuvust süsinikdioksiidi emissioonide ja aja vahel:

```{r}
modelForCo2Emissions1 = lm(log(co2Emissions1) ~ year1)
ggplot(data = world1, mapping = aes(x = year1, y = co2Emissions1)) +
  labs(x = "Aasta", y = "Süsinikdioksiidi emissioone (t)") +
  geom_point() +
  geom_line() +
  #ylim(6, NA) +
  geom_smooth() +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")), formula = log(population1) ~ year1) +
  stat_function(fun = function (x) exp(coef(modelForCo2Emissions1)[1]) * exp(coef(modelForCo2Emissions1)[2] * x), color = "red") +
  annotation_logticks(sides ="lr") +
  #scale_x_log10() 
  scale_y_log10()
summaryForModelForCo2Emissions1 = summary(modelForCo2Emissions1)
summaryForModelForCo2Emissions1
```

R ruudus on .9891, kui lineariseerida graafik selliselt, et ordinaattelg logaritmida. Seega on seos aja kulgu ja süsinikdioksiidi emissioonide suurenemise vahel maailmas niimoodi tugev.